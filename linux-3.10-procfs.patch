From cfed26bf7fe6f8cc6787d987d63b470fc04d614f Mon Sep 17 00:00:00 2001
From: Andreas Beckmann <anbe@debian.org>
Date: Sun, 18 Aug 2013 17:12:13 +0200
Subject: [PATCH] adjust for Linux 3.10 procfs interface changes

backported from 304.108 and adjusted for 173xx

Bug-Debian: http://bugs.debian.org/717306
---
 nv-linux.h |    1 +
 nv.c       |  333 +++++++++++++++++++++++++++++++++---------------------------
 2 files changed, 184 insertions(+), 150 deletions(-)

diff --git a/nv-linux.h b/nv-linux.h
index 963e059..9aac81a 100644
--- a/usr/src/nv/nv-linux.h
+++ b/usr/src/nv/nv-linux.h
@@ -163,6 +163,7 @@
 
 #ifdef CONFIG_PROC_FS
 #include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 #endif
 
 #ifdef CONFIG_MTRR
diff --git a/nv.c b/nv.c
index f82e46f..898f372 100644
--- a/usr/src/nv/nv.c
+++ b/usr/src/nv/nv.c
@@ -333,12 +333,12 @@ void          nv_kern_rc_timer(unsigned long);
 static int    nv_kern_apm_event(struct pm_dev *, pm_request_t, void *);
 #endif
 
-static int    nv_kern_read_cardinfo(char *, char **, off_t off, int, int *, void *);
-static int    nv_kern_read_status(char *, char **, off_t off, int, int *, void *);
-static int    nv_kern_read_registry(char *, char **, off_t off, int, int *, void *);       
-static int    nv_kern_read_agpinfo(char *, char **, off_t off, int, int *, void *);
-static int    nv_kern_read_version(char *, char **, off_t off, int, int *, void *);
-static int    nv_kern_read_text_file(char *, char **, off_t off, int, int *, void *);
+static const struct file_operations nv_procfs_text_file_fops;
+static const struct file_operations nv_procfs_card_info_fops;
+static const struct file_operations nv_procfs_version_fops;
+static const struct file_operations nv_procfs_agp_info_fops;
+static const struct file_operations nv_procfs_agp_status_fops;
+static const struct file_operations nv_procfs_registry_fops;
 
 int           nv_kern_ctl_open(struct inode *, struct file *);
 int           nv_kern_ctl_close(struct inode *, struct file *);
@@ -604,6 +604,92 @@ static struct pci_dev* nv_get_pci_device(nv_state_t *nv)
     return NULL;
 }
 
+#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
+#define NV_SET_PROC_ENTRY_OWNER(entry) ((entry)->owner = THIS_MODULE)
+#else
+#define NV_SET_PROC_ENTRY_OWNER(entry)
+#endif
+
+#if defined(NV_PROC_CREATE_DATA_PRESENT)
+# define NV_CREATE_PROC_ENTRY(name,mode,parent,fops,__data) \
+    proc_create_data(name, __mode, parent, fops, __data)
+#else
+# define NV_CREATE_PROC_ENTRY(name,mode,parent,fops,__data) \
+   ({                                                       \
+        struct proc_dir_entry *__entry;                     \
+        __entry = create_proc_entry(name, mode, parent);    \
+        if (__entry != NULL)                                \
+        {                                                   \
+            NV_SET_PROC_ENTRY_OWNER(__entry);               \
+            __entry->proc_fops = fops;                      \
+            __entry->data = (__data);                       \
+        }                                                   \
+        __entry;                                            \
+    })
+#endif
+
+#define NV_CREATE_PROC_FILE(filename,parent,__name,__data)               \
+   ({                                                                    \
+        struct proc_dir_entry *__entry;                                  \
+        int __mode = (S_IFREG | S_IRUGO);                                \
+        const struct file_operations *fops = &nv_procfs_##__name##_fops; \
+        if (fops->write != 0)                                            \
+            __mode |= S_IWUSR;                                           \
+        __entry = NV_CREATE_PROC_ENTRY(filename, __mode, parent, fops,   \
+            __data);                                                     \
+        __entry;                                                         \
+    })
+
+/*
+ * proc_mkdir_mode exists in Linux 2.6.9, but isn't exported until Linux 3.0.
+ * Use the older interface instead unless the newer interface is necessary.
+ */
+#if defined(NV_PROC_REMOVE_PRESENT)
+# define NV_PROC_MKDIR_MODE(name, mode, parent)                \
+    proc_mkdir_mode(name, mode, parent)
+#else
+# define NV_PROC_MKDIR_MODE(name, mode, parent)                \
+   ({                                                          \
+        struct proc_dir_entry *__entry;                        \
+        __entry = create_proc_entry(name, mode, parent);       \
+        if (__entry != NULL)                                   \
+            NV_SET_PROC_ENTRY_OWNER(__entry);                  \
+        __entry;                                               \
+    })
+#endif
+
+#define NV_CREATE_PROC_DIR(name,parent)                        \
+   ({                                                          \
+        struct proc_dir_entry *__entry;                        \
+        int __mode = (S_IFDIR | S_IRUGO | S_IXUGO);            \
+        __entry = NV_PROC_MKDIR_MODE(name, __mode, parent);    \
+        __entry;                                               \
+    })
+
+#if defined(NV_PDE_DATA_PRESENT)
+# define NV_PDE_DATA(inode) PDE_DATA(inode)
+#else
+# define NV_PDE_DATA(inode) PDE(inode)->data
+#endif
+
+#define NV_DEFINE_PROCFS_SINGLE_FILE(__name)                                  \
+    static int nv_procfs_open_##__name(                                       \
+        struct inode *inode,                                                  \
+        struct file *filep                                                    \
+    )                                                                         \
+    {                                                                         \
+        return single_open(filep, nv_procfs_read_##__name,                    \
+            NV_PDE_DATA(inode));                                              \
+    }                                                                         \
+                                                                              \
+    static const struct file_operations nv_procfs_##__name##_fops = {         \
+        .owner      = THIS_MODULE,                                            \
+        .open       = nv_procfs_open_##__name,                                \
+        .read       = seq_read,                                               \
+        .llseek     = seq_lseek,                                              \
+        .release    = single_release,                                         \
+    };
+
 static void nvos_proc_create(void)
 {
 #ifdef CONFIG_PROC_FS
@@ -614,42 +700,25 @@ static void nvos_proc_create(void)
     struct proc_dir_entry *entry;
     struct proc_dir_entry *proc_nvidia_agp, *proc_nvidia_cards;
 
-    /* world readable directory */
-    int d_flags = S_IFDIR | S_IRUGO | S_IXUGO;
-
-    /* world readable file */
-    int flags = S_IFREG | S_IRUGO;
-
     nv_state_t *nv;
     nv_linux_state_t *nvl;
 
-    proc_nvidia = create_proc_entry("driver/nvidia", d_flags, NULL);
+    proc_nvidia = NV_CREATE_PROC_DIR("driver/nvidia", NULL);
     if (!proc_nvidia)
         goto failed;
 
-    proc_nvidia_cards = create_proc_entry("cards", d_flags, proc_nvidia);
+    proc_nvidia_cards = NV_CREATE_PROC_DIR("cards", proc_nvidia);
     if (!proc_nvidia_cards)
         goto failed;
 
-    proc_nvidia_warnings = create_proc_entry("warnings", d_flags, proc_nvidia);
+    proc_nvidia_warnings = NV_CREATE_PROC_DIR("warnings", proc_nvidia);
     if (!proc_nvidia_warnings)
         goto failed;
 
-    proc_nvidia_patches = create_proc_entry("patches", d_flags, proc_nvidia);
+    proc_nvidia_patches = NV_CREATE_PROC_DIR("patches", proc_nvidia);
     if (!proc_nvidia_patches)
         goto failed;
 
-    /*
-     * Set the module owner to ensure that the reference
-     * count reflects accesses to the proc files.
-     */
-#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
-    proc_nvidia->owner = THIS_MODULE;
-    proc_nvidia_cards->owner = THIS_MODULE;
-    proc_nvidia_warnings->owner = THIS_MODULE;
-    proc_nvidia_patches->owner = THIS_MODULE;
-#endif
-
     for (j = 0; j < num_nv_devices; j++)
     {
         nvl = &nv_linux_devices[j];
@@ -660,92 +729,56 @@ static void nvos_proc_create(void)
             break;
 
         sprintf(name, "%d", i++);
-        entry = create_proc_entry(name, flags, proc_nvidia_cards);
+        entry = NV_CREATE_PROC_FILE(name, proc_nvidia_cards, card_info, nv);
         if (!entry) {
             NV_PCI_DEV_PUT(dev);
             goto failed;
         }
 
-        entry->data = nv;
-        entry->read_proc = nv_kern_read_cardinfo;
-#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
-        entry->owner = THIS_MODULE;
-#endif
-
         if (nvos_find_agp_capability(dev)) {
             /*
              * Create the /proc/driver/nvidia/agp/{status,host-bridge,card}
              * entries now that we know there's AGP hardware.
              */
-            entry = create_proc_entry("agp", d_flags, proc_nvidia);
+            entry = NV_CREATE_PROC_DIR("agp", proc_nvidia);
             if (!entry) {
                 NV_PCI_DEV_PUT(dev);
                 goto failed;
             }
 
-#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
-            entry->owner = THIS_MODULE;
-#endif
             proc_nvidia_agp = entry;
 
-            entry = create_proc_entry("status", flags, proc_nvidia_agp);
+            entry = NV_CREATE_PROC_FILE("status", proc_nvidia_agp, agp_status, nv);
             if (!entry) {
                 NV_PCI_DEV_PUT(dev);
                 goto failed;
             }
 
-            entry->data = nv;
-            entry->read_proc = nv_kern_read_status;
-#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
-            entry->owner = THIS_MODULE;
-#endif
-
-            entry = create_proc_entry("host-bridge", flags, proc_nvidia_agp);
+            entry = NV_CREATE_PROC_FILE("host-bridge", proc_nvidia_agp, agp_info, NULL);
             if (!entry) {
                 NV_PCI_DEV_PUT(dev);
                 goto failed;
             }
 
-            entry->data = NULL;
-            entry->read_proc = nv_kern_read_agpinfo;
-#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
-            entry->owner = THIS_MODULE;
-#endif
-
-            entry = create_proc_entry("card", flags, proc_nvidia_agp);
+            entry = NV_CREATE_PROC_FILE("card", proc_nvidia_agp, agp_info, nv);
             if (!entry) {
                 NV_PCI_DEV_PUT(dev);
                 goto failed;
             }
 
-            entry->data = nv;
-            entry->read_proc = nv_kern_read_agpinfo;
-#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
-            entry->owner = THIS_MODULE;
-#endif
         }
 
         NV_PCI_DEV_PUT(dev);
     }
 
-    entry = create_proc_entry("version", flags, proc_nvidia);
+    entry = NV_CREATE_PROC_FILE("version", proc_nvidia, version, NULL);
     if (!entry)
         goto failed;
 
-    entry->read_proc = nv_kern_read_version;
-#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
-    entry->owner = THIS_MODULE;
-#endif
-
-    entry = create_proc_entry("registry", flags, proc_nvidia);
+    entry = NV_CREATE_PROC_FILE("registry", proc_nvidia, registry, NULL);
     if (!entry)
         goto failed;
 
-    entry->read_proc = nv_kern_read_registry;
-#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
-    entry->owner = THIS_MODULE;
-#endif
-
     return;
 
 failed:
@@ -762,25 +795,16 @@ nvos_proc_add_text_file(
 )
 {
 #ifdef CONFIG_PROC_FS
-    struct proc_dir_entry *entry;
-
-    /* world readable file */
-    int flags = S_IFREG | S_IRUGO;
-
-    entry = create_proc_entry(filename, flags, parent);
-    if (!entry) return;
-
-    entry->data = (void *)text;
-    entry->read_proc = nv_kern_read_text_file;
-#if defined(NV_PROC_DIR_ENTRY_HAS_OWNER)
-    entry->owner = THIS_MODULE;
-#endif
+    NV_CREATE_PROC_FILE(filename, parent, text_file, (void *)text);
 #endif
 }
 
 #ifdef CONFIG_PROC_FS
 static void nvos_proc_remove_all(struct proc_dir_entry *entry)
 {
+#if defined(NV_PROC_REMOVE_PRESENT)
+    proc_remove(entry);
+#else
     while (entry) {
         struct proc_dir_entry *next = entry->next;
         if (entry->subdir)
@@ -790,6 +814,7 @@ static void nvos_proc_remove_all(struct proc_dir_entry *entry)
             break;
         entry = next;
     }
+#endif
 }
 #endif
 
@@ -3065,19 +3090,18 @@ void   NV_API_CALL  nv_set_dma_address_size(
 }
 
 static int
-nv_kern_read_cardinfo(char *page, char **start, off_t off,
-        int count, int *eof, void *data)
+nv_procfs_read_card_info(
+    struct seq_file *s,
+    void *v
+)
 {
+    nv_state_t *nv = s->private;
     struct pci_dev *dev;
     char *type, *fmt, tmpstr[NV_DEVICE_NAME_LENGTH];
-    int len = 0, status;
+    int status;
     U032 vbios_rev1, vbios_rev2, vbios_rev3, vbios_rev4, vbios_rev5;
     nv_stack_t *sp = NULL;
 
-    nv_state_t *nv;
-    nv = (nv_state_t *) data;
-    *eof = 1;
-
     dev = nv_get_pci_device(nv);
     if (!dev)
         return 0;
@@ -3094,38 +3118,38 @@ nv_kern_read_cardinfo(char *page, char **start, off_t off,
         strcpy (tmpstr, "Unknown");
     }
     
-    len += sprintf(page+len, "Model: \t\t %s\n", tmpstr);
-    len += sprintf(page+len, "IRQ:   \t\t %d\n", nv->interrupt_line);
+    seq_printf(s, "Model: \t\t %s\n", tmpstr);
+    seq_printf(s, "IRQ:   \t\t %d\n", nv->interrupt_line);
 
     status = rm_get_vbios_version(sp, nv, &vbios_rev1, &vbios_rev2,
                                   &vbios_rev3, &vbios_rev4, &vbios_rev5);
 
     if (status < 0) {
         /* before rm_init_adapter */
-        len += sprintf(page+len, "Video BIOS: \t ??.??.??.??.??\n");
+        seq_printf(s, "Video BIOS: \t ??.??.??.??.??\n");
     } else {
         fmt = "Video BIOS: \t %02x.%02x.%02x.%02x.%02x\n";
-        len += sprintf(page+len, fmt, vbios_rev1, vbios_rev2, vbios_rev3,
+        seq_printf(s, fmt, vbios_rev1, vbios_rev2, vbios_rev3,
                                                   vbios_rev4, vbios_rev5);
     }
 
     if (nvos_find_agp_capability(dev)) type = "AGP";
     else if (nvos_find_pci_express_capability(dev)) type = "PCI-E";
     else type = "PCI";
-    len += sprintf(page+len, "Card Type: \t %s\n", type);
+    seq_printf(s, "Card Type: \t %s\n", type);
 
     // Report the number of bits set in dev->dma_mask
-    len += sprintf(page+len, "DMA Size: \t %d bits\n",
+    seq_printf(s, "DMA Size: \t %d bits\n",
      nv_count_bits(dev->dma_mask));
-    len += sprintf(page+len, "DMA Mask: \t 0x%llx\n", dev->dma_mask);
-    len += sprintf(page+len, "Bus Location: \t %02x.%02x.%x\n",
+    seq_printf(s, "DMA Mask: \t 0x%llx\n", dev->dma_mask);
+    seq_printf(s, "Bus Location: \t %02x.%02x.%x\n",
                    nv->bus, nv->slot, PCI_FUNC(dev->devfn));
 #ifdef DEBUG
     do
     {
         int j;
         for (j = 0; j < NV_GPU_NUM_BARS; j++)
-            len += sprintf(page+len, "BAR%i: \t\t 0x%08x (%iMB)\n",
+            seq_printf(s, "BAR%i: \t\t 0x%08x (%iMB)\n",
                            j, nv->bars[j].address, nv->bars[j].size >> 20);
     } while(0);
 #endif
@@ -3133,35 +3157,36 @@ nv_kern_read_cardinfo(char *page, char **start, off_t off,
     NV_KMEM_CACHE_FREE_STACK(sp);
  
     NV_PCI_DEV_PUT(dev);
-    return len;
+    return 0;
 }
 
+NV_DEFINE_PROCFS_SINGLE_FILE(card_info);
+
 static int
-nv_kern_read_version(char *page, char **start, off_t off,
-        int count, int *eof, void *data)
+nv_procfs_read_version(
+    struct seq_file *s,
+    void *v
+)
 {
-    int len = 0;
-    *eof = 1;
-    
-    len += sprintf(page+len, "NVRM version: %s\n", pNVRM_ID);
-    len += sprintf(page+len, "GCC version:  %s\n", NV_COMPILER);
-    
-    return len;
+    seq_printf(s, "NVRM version: %s\n", pNVRM_ID);
+    seq_printf(s, "GCC version:  %s\n", NV_COMPILER);
+
+    return 0;
 }
 
+NV_DEFINE_PROCFS_SINGLE_FILE(version);
+
 static int
-nv_kern_read_agpinfo(char *page, char **start, off_t off,
-        int count, int *eof, void *data)
+nv_procfs_read_agp_info(
+    struct seq_file *s,
+    void *v
+)
 {
+    nv_state_t *nv = s->private;
     struct pci_dev *dev;
     char   *fw, *sba;
     u8     cap_ptr;
     u32    status, command, agp_rate;
-    int    len = 0;
-    
-    nv_state_t *nv;
-    nv = (nv_state_t *) data;
-    *eof = 1;
 
     if (nv) {
         dev = nv_get_pci_device(nv);
@@ -3172,12 +3197,12 @@ nv_kern_read_agpinfo(char *page, char **start, off_t off,
         if (!dev)
             return 0;
 
-        len += sprintf(page+len, "Host Bridge: \t ");
+        seq_printf(s, "Host Bridge: \t ");
 
 #if defined(CONFIG_PCI_NAMES)
-        len += sprintf(page+len, "%s\n", NV_PCI_DEVICE_NAME(dev));
+        seq_printf(s, "%s\n", NV_PCI_DEVICE_NAME(dev));
 #else
-        len += sprintf(page+len, "PCI device %04x:%04x\n",
+        seq_printf(s, "PCI device %04x:%04x\n",
                 dev->vendor, dev->device);
 #endif
     }
@@ -3191,41 +3216,41 @@ nv_kern_read_agpinfo(char *page, char **start, off_t off,
     fw  = (status & 0x00000010) ? "Supported" : "Not Supported";
     sba = (status & 0x00000200) ? "Supported" : "Not Supported";
 
-    len += sprintf(page+len, "Fast Writes: \t %s\n", fw);
-    len += sprintf(page+len, "SBA: \t\t %s\n", sba);
+    seq_printf(s, "Fast Writes: \t %s\n", fw);
+    seq_printf(s, "SBA: \t\t %s\n", sba);
 
     agp_rate = status & 0x7;
     if (status & 0x8) // agp 3.0
         agp_rate <<= 2;
 
-    len += sprintf(page+len, "AGP Rates: \t %s%s%s%s\n",
+    seq_printf(s, "AGP Rates: \t %s%s%s%s\n",
             (agp_rate & 0x00000008) ? "8x " : "",
             (agp_rate & 0x00000004) ? "4x " : "",
             (agp_rate & 0x00000002) ? "2x " : "",
             (agp_rate & 0x00000001) ? "1x " : "");
 
-    len += sprintf(page+len, "Registers: \t 0x%08x:0x%08x\n", status, command);
+    seq_printf(s, "Registers: \t 0x%08x:0x%08x\n", status, command);
 
     NV_PCI_DEV_PUT(dev);
-    return len;
+    return 0;
 }
 
+NV_DEFINE_PROCFS_SINGLE_FILE(agp_info);
+
 static int
-nv_kern_read_status(char *page, char **start, off_t off,
-        int count, int *eof, void *data)
+nv_procfs_read_agp_status(
+    struct seq_file *s,
+    void *v
+)
 {
+    nv_state_t *nv = s->private;
     struct pci_dev *dev;
     char   *fw, *sba, *drv;
-    int    len = 0;
     u8     cap_ptr;
     u32    scratch;
     u32    status, command, agp_rate;
     nv_stack_t *sp = NULL;
 
-    nv_state_t *nv;
-    nv = (nv_state_t *) data;
-    *eof = 1;
-
     dev = nvos_get_agp_device_by_class(PCI_CLASS_BRIDGE_HOST);
     if (!dev)
         return 0;
@@ -3246,10 +3271,10 @@ nv_kern_read_status(char *page, char **start, off_t off,
     command &= scratch;
 
     if (NV_AGP_ENABLED(nv) && (command & 0x100)) {
-        len += sprintf(page+len, "Status: \t Enabled\n");
+        seq_printf(s, "Status: \t Enabled\n");
 
         drv = NV_OSAGP_ENABLED(nv) ? "AGPGART" : "NVIDIA";
-        len += sprintf(page+len, "Driver: \t %s\n", drv);
+        seq_printf(s, "Driver: \t %s\n", drv);
 
         // mask off agp rate. 
         // If this is agp 3.0, we need to shift the value
@@ -3257,13 +3282,13 @@ nv_kern_read_status(char *page, char **start, off_t off,
         if (status & 0x8) // agp 3.0
             agp_rate <<= 2;
 
-        len += sprintf(page+len, "AGP Rate: \t %dx\n", agp_rate);
+        seq_printf(s, "AGP Rate: \t %dx\n", agp_rate);
 
         fw = (command & 0x00000010) ? "Enabled" : "Disabled";
-        len += sprintf(page+len, "Fast Writes: \t %s\n", fw);
+        seq_printf(s, "Fast Writes: \t %s\n", fw);
 
         sba = (command & 0x00000200) ? "Enabled" : "Disabled";
-        len += sprintf(page+len, "SBA: \t\t %s\n", sba);
+        seq_printf(s, "SBA: \t\t %s\n", sba);
     } else {
         int agp_config = 0;
 
@@ -3274,7 +3299,7 @@ nv_kern_read_status(char *page, char **start, off_t off,
             return 0;
         }
 
-        len += sprintf(page+len, "Status: \t Disabled\n\n");
+        seq_printf(s, "Status: \t Disabled\n\n");
 
         /*
          * If we find AGP is disabled, but the RM registry indicates it
@@ -3288,7 +3313,7 @@ nv_kern_read_status(char *page, char **start, off_t off,
         rm_read_registry_dword(sp, nv, "NVreg", "XNvAGP", &agp_config);
 
         if (agp_config != NVOS_AGP_CONFIG_DISABLE_AGP && NV_AGP_FAILED(nv)) {
-            len += sprintf(page+len,
+            seq_printf(s,
                   "AGP initialization failed, please check the ouput  \n"
                   "of the 'dmesg' command and/or your system log file \n"
                   "for additional information on this problem.        \n");
@@ -3298,37 +3323,45 @@ nv_kern_read_status(char *page, char **start, off_t off,
     }
 
     NV_PCI_DEV_PUT(dev);
-    return len;
+    return 0;
 }
 
+NV_DEFINE_PROCFS_SINGLE_FILE(agp_status);
+
 extern nv_parm_t nv_parms[];
 extern char *NVreg_RegistryDwords;
 
 static int
-nv_kern_read_registry(char *page, char **start, off_t off,
-        int count, int *eof, void *data)
+nv_procfs_read_registry(
+    struct seq_file *s,
+    void *v
+)
 {
-    unsigned int i, len = 0;
+    unsigned int i;
     nv_parm_t *entry;
-    *eof = 1;
 
     for (i = 0; (entry = &nv_parms[i])->name != NULL; i++)
-        len += sprintf(page+len, "%s: %u\n", entry->name, *entry->data);
+        seq_printf(s, "%s: %u\n", entry->name, *entry->data);
 
-    len += sprintf(page+len, "RegistryDwords: \"%s\"\n",
+    seq_printf(s, "RegistryDwords: \"%s\"\n",
                 (NVreg_RegistryDwords != NULL) ? NVreg_RegistryDwords : "");
 
-    return len;
+    return 0;
 }
 
+NV_DEFINE_PROCFS_SINGLE_FILE(registry);
+
 static int
-nv_kern_read_text_file(char *page, char **start, off_t off,
-        int count, int *eof, void *data)
+nv_procfs_read_text_file(
+    struct seq_file *s,
+    void *v
+)
 {
-    *eof = 1;
-    return sprintf(page, "%s", (char *)data);
+    return seq_puts(s, s->private);
 }
 
+NV_DEFINE_PROCFS_SINGLE_FILE(text_file);
+
 /***
  *** EXPORTS to rest of resman
  ***/
-- 
1.7.10.4

